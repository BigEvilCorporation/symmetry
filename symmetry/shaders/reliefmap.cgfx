/*

% Relief Mapping
% Matt Phillips
% Based on code from NVIDIA Shader Library

keywords: relief bump map

date: 8/6/08

*/

///////////////////////////////
//Tweakables
///////////////////////////////
float3 LightPos : POSITION
<
    string UIWidget = "PointLight0";
    string UIName =  "Light Position";
    string Space = "World";
> = {-0.5f,2.0f,1.25f};

float UTile
<
    string UIName = "U Tiling";
    string UIWidget = "slider";
    float UIMin = 0.1;
    float UIStep = 1.0;
    float UIMax = 32.0;
> = 1;

float VTile
<
    string UIName = "V Tiling";
    string UIWidget = "slider";
    float UIMin = 0.1;
    float UIStep = 1.0;
    float UIMax = 32.0;
> = 1;

float UOffset
<
    string UIName = "U Offset";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIStep = 0.01;
    float UIMax = 1.0;
> = 1;

float VOffset
<
    string UIName = "V Offset";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIStep = 0.01;
    float UIMax = 1.0;
> = 1;

float3 Ambient
<
    string UIName = "Ambient";
    string UIWidget = "color";
> = {0.2,0.2,0.2};

float3 Diffuse
<
    string UIName = "Diffuse";
    string UIWidget = "color";
> = {1,1,1};

float3 Specular
<
    string UIName = "Specular";
    string UIWidget = "color";
> = {0.75,0.75,0.75};

float PhongExp
<
    string UIName = "Phong Exponent";
    string UIWidget = "slider";
    float UIMin = 8.0f;
    float UIStep = 8;
    float UIMax = 256.0f;
> = 128.0;

float Depth
<
    string UIName = "Depth";
    string UIWidget = "slider";
    float UIMin = 0.0f;
    float UIStep = 0.001f;
    float UIMax = 0.25f;
> = 0.05;


///////////////////////////////
//Textures
///////////////////////////////
texture DiffuseTexture
<
    string UIName =  "Diffuse Texture";
    string ResourceType = "2D";
>;

texture NormalMapTexture
<
    string UIName =  "Normal Map Texture";
    string ResourceType = "2D";
>;


///////////////////////////////
//Samplers
///////////////////////////////
sampler2D DiffuseSampler = sampler_state
{
    Texture = <DiffuseTexture>;
    MinFilter = LinearMipMapLinear;
    MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Repeat;
};

sampler2D NormalMapSampler = sampler_state
{
    Texture = <NormalMapTexture>;
    MinFilter = LinearMipMapLinear;
    MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Repeat;
};

///////////////////////////////
//Inputs
///////////////////////////////
float4x4 WorldIT : WORLDINVERSETRANSPOSE;
float4x4 WorldViewProj : WORLDVIEWPROJECTION;
float4x4 World : WORLD;
float4x4 ViewInverse : VIEWINVERSE;
float4x4 View : VIEW;
float4x4 WorldView: WORLDVIEW;

///////////////////////////////
//Functions
///////////////////////////////
float ray_intersect_rm(in sampler2D reliefmap, in float2 dp, in float2 ds)
{
   const int linear_search_steps=15;
   
   //Current size of search window
   float size = 1.0 / linear_search_steps;
   
   //Current depth position
   float depth = 0.0;
   
   //Search front to back for first point inside object
   for(int i = 0; i < linear_search_steps - 1; i++)
   {
		float4 t = tex2D(reliefmap, dp + ds * depth);
		if (depth < t.w) depth += size;
   }
   
   const int binary_search_steps = 5;
   
   //Recurse around first point (depth) for closest match
   for(int i=0;i<binary_search_steps; i++)
   {
		size*=0.5;
		float4 t = tex2D(reliefmap, dp + ds * depth);
		if (depth < t.w) depth += (2 * size);
		depth -= size;
   }
   
   return depth;
}

float ray_intersect_rm_lin(in sampler2D reliefmap, in float2 dp, in float2 ds)
{
   const int linear_search_steps = 15;
   
   //Current size of search window
   float size = 1.0 / linear_search_steps;
   
   //Current depth position
   float depth = 0.0;
   
   //Search front to back for first point inside object
   for(int i = 0; i < linear_search_steps - 1; i++)
   {
		float4 t = tex2D(reliefmap, dp + ds * depth);
		if (depth < t.w) depth += size;
   }
   return depth;
}


///////////////////////////////
//Structs
///////////////////////////////
struct VInput
{
    float4 Position	: POSITION;
    float4 Colour	: COLOR0;
    float3 Normal	: NORMAL;
    float2 UVCoord	: TEXCOORD0;
    float3 Tangent	: TANGENT0;
    float3 Binormal	: BINORMAL0;
};

struct VOutput
{
    float4 HPosition	: POSITION;
    float2 UVCoord		: TEXCOORD0;
    float3 VPosition	: TEXCOORD1;
    float3 Tangent		: TEXCOORD2;
    float3 Binormal		: TEXCOORD3;
    float3 Normal		: TEXCOORD4;
    float4 LightPos		: TEXCOORD5;
    float4 Colour		: COLOR0;
};


///////////////////////////////
//Vertex shader
///////////////////////////////
VOutput VShader(VInput IN)
{
	//Create output object
	VOutput OUT;
	
    //Get WorldView rotation
    float3x3 ModelViewRot;
    ModelViewRot[0] = WorldView[0].xyz;
    ModelViewRot[1] = WorldView[1].xyz;
    ModelViewRot[2] = WorldView[2].xyz;
	
    float4 Po = float4(IN.Position.xyz, 1.0);
    OUT.HPosition = mul(WorldViewProj, Po);
	
    //Vertex position in view space (with model transformations)
    OUT.VPosition = mul(WorldView, Po).xyz;
	
    //Light position in view space
    float4 Lw = float4(LightPos.xyz, 1.0);
    OUT.LightPos = mul(View, Lw);
	
    //Tangent space vectors in view space (with model transformations)
    OUT.Tangent = mul(ModelViewRot, IN.Tangent);
    OUT.Binormal = mul(ModelViewRot, IN.Binormal);
    OUT.Normal = mul(ModelViewRot, IN.Normal);
	
    //Copy colour
    OUT.Colour = IN.Colour;
	
	//UV tiling and offset
	OUT.UVCoord.x = IN.UVCoord.x * UTile + UOffset;
	OUT.UVCoord.y = IN.UVCoord.y * VTile + VOffset;
	
    return OUT;
}


///////////////////////////////
//Pixel shader
///////////////////////////////
float4 PShader(VOutput IN) : COLOR
{
    //Ray intersect in view direction
    float3 p = IN.VPosition;
    float3 Vn = normalize(p);
    float a = dot(IN.Normal, -Vn);
    float3 s = float3(dot(Vn, IN.Tangent.xyz), dot(Vn, IN.Binormal.xyz), a);
    s *= Depth / a;
    float2 ds = s.xy;
    float2 dp = IN.UVCoord;
    float d  = ray_intersect_rm(NormalMapSampler, dp, ds);
	
    //Get rm and color texture points
    float2 uv = dp+ds*d;
    float3 texCol = tex2D(DiffuseSampler, uv).xyz;
    float3 tNorm = tex2D(NormalMapSampler, uv).xyz - float3(0.5, 0.5, 0.5);
    tNorm = normalize(	tNorm.x * IN.Tangent -
		    			tNorm.y * IN.Binormal + 
		    			tNorm.z * IN.Normal);
						
    //Compute light direction
    p += Vn * d / (a * Depth);
    float3 Ln = normalize(p - IN.LightPos.xyz);
	
    //Compute diffuse and specular terms
    float Attenuation = saturate(dot(-Ln, IN.Normal));
    float Diff = saturate(dot(-Ln, tNorm));
    float Spec = saturate(dot(normalize(-Ln-Vn), tNorm));
	
    //Ray intersect in light direction
    dp += ds * d;
    a = dot(IN.Normal, -Ln);
    s = float3(dot(Ln, IN.Tangent.xyz), dot(Ln, IN.Binormal.xyz), a);
    s *= Depth / a;
    ds = s.xy;
    dp -= ds * d;
    float dl = ray_intersect_rm_lin(NormalMapSampler, dp, s.xy);
    if (dl < d - 0.05)
	{
      Diff *= dot(Ambient.xyz, float3(1.0, 1.0, 1.0)) * 0.333333;
      Spec = 0;
    }
	
    Spec = pow(Spec, PhongExp);
	
    //Compute final color
    float3 Colour = Ambient * texCol +
					Attenuation * (texCol * Diffuse * Diff + Specular * Spec);
					
    return float4(Colour.rgb, 1.0);
}


///////////////////////////////
//Techniques
///////////////////////////////
technique Main
{
	pass p0
	{
		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		BlendEnable = false;
		DepthFunc = LEqual;
		
		VertexProgram = compile vp20 VShader();
		FragmentProgram = compile fp30 PShader();
	}
}